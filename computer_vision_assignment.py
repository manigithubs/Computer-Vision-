# -*- coding: utf-8 -*-
"""Computer Vision Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nDd7u17zHrQRh2TH1OYK5Qz0oqkKuOrt

# **Computer Vision Assignment**

Objective 1: Count the number of rice grains in the Image.

Objective 2: Find the number of broken grains in the image.

You can assume the following in the image:

● The background will always be blue.

● There will be a mix of broken and non-broken rice grains.

● The grains will not overlap but can touch each other.

### To solve the two objectives, the following approach and technology can be used:

Image processing: Image processing is a field of study that focuses on the processing and analysis of images. The main goal of image processing is to extract useful information from images.

Object recognition: Object recognition is a technique used to identify objects in an image. The objects are recognized based on their shape, color, texture, and other features.

Image segmentation: Image segmentation is a process of dividing an image into multiple regions based on their properties, such as color, texture, and shape. This process is used to separate objects in an image from the background.

Feature extraction: Feature extraction is the process of identifying important features in an image that can be used to recognize objects or classify the image.

Machine learning: Machine learning is a subfield of artificial intelligence that focuses on the development of algorithms and models that can learn from and make predictions on data.

# <<<For the first objective, the following steps can be used:

For the first objective, the following steps can be used:

Preprocessing: The image will be preprocessed to remove noise and improve the quality of the image.

Segmentation: The image will be segmented to separate the rice grains from the background.

Feature extraction: Features such as color, shape, and texture will be extracted from the segmented image to identify the rice grains.

Object recognition: Object recognition techniques will be used to count the number of rice grains in the image.

# <<<For the second objective, the following steps can be used:

For the second objective, the following steps can be used:

Preprocessing: The image will be preprocessed to remove noise and improve the quality of the image.

Segmentation: The image will be segmented to separate the rice grains from the background.

Feature extraction: Features such as color, shape, and texture will be extracted from the segmented image to identify the broken rice grains.

Object recognition: Object recognition techniques will be used to count the number of broken rice grains in the image.

# Technology used: Computer Vision, OpenCv, WaterShed Algorithm, Image Preprocessing, Image Segmentation, and others.

The major challenge in solving the objectives of counting the number of rice grains and finding the number of broken grains in an image is to accurately differentiate between rice grains and broken rice grains. This can be challenging due to several factors such as:

Image quality: The quality of the image, such as resolution and lighting, can affect the accuracy of the results.

Complexity of the image: The complexity of the image, such as the presence of shadows and reflections, can make it difficult to accurately segment and recognize objects.

Variability of rice grain shapes: Rice grains can have different shapes and sizes, making it difficult to accurately recognize and differentiate between them.

Similarity between rice grains and background: Rice grains may have similar colors or textures as the background, making it difficult to separate them.

Similarity between broken rice grains and whole rice grains: Broken rice grains may have similar shapes and textures as whole rice grains, making it difficult to accurately differentiate between them.

The problem of touching or overlapping rice grains can be solved using image processing techniques. One common approach is to use the Watershed algorithm, which is a popular image segmentation technique that can accurately detect and separate touching objects in an image. Another approach is to use a Neural Network, which can be trained to recognize and count the number of grains in an image. The choice of method will depend on the specific requirements of the task at hand, including the quality of the input images, processing time constraints, and the desired level of accuracy. In any case, it is important to carefully evaluate the quality of the input images and perform appropriate pre-processing steps to ensure accurate results.

# Importing The packages
"""

import os
os.listdir()

#Importing openCv both as cv2 and cv for better convinence 
import cv2  
import cv2 as cv 

# Importing numpy for working with numpy arrays
import numpy as np 

# Importing pyplot as plt from maplotlib for Image Visualization
from matplotlib import pyplot as plt 

#Collab not support cv2.imshow method thus, importing cv2.imshow method for better Image visualization 
from google.colab.patches import cv2_imshow  

#Importing PIL library for working with Images
from PIL import Image 

#Importing asarray method from numpy for dealing with pixels of Images
from numpy import asarray 

import matplotlib.image as mpimg

#Importing ndimage from scipy as this package contains various functions for multidimensional image processing.
from scipy import ndimage

#Importing filters, features, measures and color from skimage
from skimage import filters, feature, measure, color

#Importing Watershed for touching Grains sepration
from skimage.segmentation import watershed

def show(image,x=30,y=7):
  img=cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
  plt.figure(figsize=(x,y))
  plt.imshow(img)

"""# Importing the images """

#Reading Image
img = cv2.imread("/content/image_1.jpg")

#Using predefined show function for displaying the image
show(img,25,5)

"""# Converting the Images Grayscale conversion: Image thresholding:

Grayscale conversion: Grayscale conversion is the process of converting a color image into a grayscale image. A grayscale image has only one channel, representing the intensity of the light in the image, while a color image has three channels, representing the red, green, and blue channels. Grayscale conversion is useful because it reduces the amount of data required to represent an image and simplifies image analysis.

Image thresholding: Image thresholding is the process of converting an image into a binary image by dividing it into two classes, black and white, based on a threshold value. The threshold value is chosen based on the intensity levels of the pixels in the image. Image thresholding is useful in image analysis because it reduces the amount of information in an image and simplifies image segmentation
"""

#Converting Image BGR Image to Gray for Image thresholding and further Image-Preprocessing application
grayscale_Image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
ret, thresh_img = cv2.threshold(grayscale_Image, 120, 255, cv2.THRESH_BINARY)

#Using show function earlier defined
show(thresh_img)

"""# Noise Removal

Noise removal is a technique used in image processing to remove unwanted noise or variations in the intensity levels of pixels in an image. Noise can be introduced into an image during acquisition, transmission, or processing and can reduce the quality of the image.
"""

# Noise removal
kernel = np.ones((3),np.uint8)
clear_image = cv2.morphologyEx(thresh_img,cv2.MORPH_OPEN, kernel, iterations=8)

#Using show function earlier defined
show(clear_image)

#Copying the preprocessed image as label_image
label_image = clear_image.copy()

#Creating a label_count variable to the count the number of grains in the image
label_count = 0

#Shape function for getting height and width
rows, cols = label_image.shape

#Looping through the pixel of image using rows and column of image
for j in range(rows):
    for i in range(cols):
        pixel = label_image[j, i]

        #Here there is single channel with 2 pixel intensities, Either 0 or 255. 0 represent black portion, where 255 represent grains (White).
        #Counting the total number of pixel with intensity 255
        if 255 == pixel:
            label_count += 1

            ##Applying floodFill method of opencv which will help in filling the backgroud that will ultimately helps in couting the contoured grain easily
            cv.floodFill(label_image, None, (i, j), label_count)

print("Number of foreground objects", label_count)
show(label_image)

"""# Counting rice grains using Contours method"""

#Applying Countours method to get the count of rice grains
contours, hierarchy = cv.findContours(clear_image, 
                                      cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)


output_contour = cv.cvtColor(clear_image, cv.COLOR_GRAY2BGR)
cv.drawContours(output_contour, contours, -1, (0, 0, 255), 2)
print("Number of detected contours", len(contours))

cv2_imshow(output_contour)

print(" \n Number of detected contours", len(contours))

"""Output_Contour Image Analysis

Looking at the ouput_image after applying contours that, there are some rice grains that are touching each other.

And this situation making the Opencv Contour method to treat those images as collection or as 1 rice grain.

Well the amount of grains that are touching each other are very few but still there needed a fix for this.

Time to fix the touching Rice grain problem!

# Applying Watershed Algorithm

The Watershed algorithm is a popular image segmentation technique that works by treating the image as a topographical map and using markers to identify the boundaries between objects. The algorithm starts by transforming the input image into a topographical representation, where the intensity values of the pixels are used to represent the height of the terrain. Then, markers are placed on the image to identify the foreground and background regions. The algorithm then uses the markers to propagate information about the boundaries between objects, and the boundaries are extracted using a "flood-fill" operation. The result is a segmented image where each object has a unique label and is separated from the other objects. The Watershed algorithm can be useful in solving the problem of touching rice grains by accurately detecting and separating the grains.
"""

#To visualize the segmentation conveniently, There needed a colour-code the labelled regions using the color, thus I did it.


#Applying  distance_transform_edt to computes the distance from non-zero (i.e. non-background) points to the nearest zero (i.e. background) point.
dist_trans = ndimage.distance_transform_edt(clear_image)

#Applying peak_local_max function for getting coordinates of local peaks (maxima) in an image.
local_max = feature.peak_local_max(dist_trans, min_distance=23)


local_max_mask = np.zeros(dist_trans.shape, dtype=bool)
local_max_mask[tuple(local_max.T)] = True

#Aplying Watershed algorithm
labels = watershed(-dist_trans, measure.label(local_max_mask), mask=clear_image) # separate merged corns

#To visualize the segmentation conveniently, There needed a colour-code the labelled regions using the color, thus I did it.


#Applying  distance_transform_edt to computes the distance from non-zero (i.e. non-background) points to the nearest zero (i.e. background) point.
dist_trans = ndimage.distance_transform_edt(clear_image)

#Applying peak_local_max function for getting coordinates of local peaks (maxima) in an image.
local_max = feature.peak_local_max(dist_trans, min_distance=23)


local_max_mask = np.zeros(dist_trans.shape, dtype=bool)
local_max_mask[tuple(local_max.T)] = True

#Aplying Watershed algorithm
labels = watershed(-dist_trans, measure.label(local_max_mask), mask=clear_image) # separate merged corns

"""# Counting Total Grains and Broken grains using grains area"""

#label2rgb function, specifying the background label with argument bg_label=0.
plt.figure(figsize=(30,10))
plt.imshow(color.label2rgb(labels, bg_label=0))
print("Number of Rice grains are : %d" % labels.max())

"""Results of WaterShed Algorithm
The results are quite better after applying the Watershed algorithm. Most of the touching rice grains are well seperated now and counting is more accurate.

In the above results, there is the total counting of 513 and here, the count is of 589.

It means, there is total gap of 76 grains.

Well, the results are not 100% accurate but it is feasible in respect of Simple countous counting.

# Objective 1 : Count the Total number of Rice grains

After carefull analysis, I found that 800 is the threshold limit for classifing the broken rice grains from the Full rice grains.

Thus applying this limit on the contour to get the results.
"""

#Creating A list name count for counting the total Broken rice grains
count = []

#Iterating through contour and filtering out the rice grains with area less than 800 and then appending to the count variable.
for x in contours:

  #Using contourArea method to get the area of rice (Contour)
  area = cv.contourArea(x)
  if area < 800 :
    count.append(x)

#Output of the count list.

print("Total number of broken rice present in the Image is: ",len(count))

"""# Objective 2 : Count the Total number of Broken rice grains

Pre-processing: Perform image pre-processing steps such as noise removal, thresholding, and morphological operations to enhance the image quality and separate the grains from the background.

Segmentation: Apply the Watershed algorithm to segment the image and separate the individual grains.

Labeling: Label each segmented object with a unique identifier, so that you can distinguish between the different grains.

Counting: Count the number of labeled objects in the image and report this as the total number of broken rice grains.

Split and Count

The "Split and Count" method is another approach to counting the number of broken rice grains. This method involves splitting the image into smaller sub-images, and then counting the number of grains in each sub-image. Here's a general outline of the steps involved in this method:

Pre-processing: Perform image pre-processing steps such as noise removal, thresholding, and morphological operations to enhance the image quality and separate the grains from the background.

Splitting: Split the image into smaller sub-images, typically by dividing the image into overlapping tiles.

Counting: Count the number of grains in each sub-image and store the results.

Aggregation: Aggregate the results from each sub-image to obtain the total number of broken rice grains in the original image.

This method can be useful in cases where the image is too large to process as a single entity, or when the quality of the image is not sufficient for accurate grain counting using other methods. However, the accuracy of this method will depend on the size and overlap of the sub-images, as well as the quality of the image and the pre-processing steps performed.

# Neural Network

Neural method to count the total number of broken rice grains is to use a Neural Network. Here's a general outline of the steps involved in this method:

Data Collection: Collect a large dataset of images of broken rice grains and annotate the images with the number of grains in each image.

Neural Network Training: Train a Neural Network using the annotated images as training data. The network should be able to predict the number of grains in a given image.

Model Validation: Evaluate the performance of the trained model on a validation dataset to ensure that it is able to accurately predict the number of grains in new images.

Deployment: Deploy the trained model in a real-world scenario, and use it to count the number of broken rice grains in a new image.

This method can be useful in cases where the quality of the images is not sufficient for accurate grain counting using other methods, or when the grain counting needs to be performed in real-time. However, the accuracy of this method will depend on the quality of the annotated data and the performance of the trained Neural Network.




Regenerate response

# End Note

In conclusion, there are several methods for counting the total number of broken rice grains, including the Watershed Algorithm, the Split and Count method, and the Neural Network training method. Each method has its own advantages and limitations, and the choice of method will depend on the specific requirements of the task at hand. It is important to carefully evaluate the quality of the input images and perform appropriate pre-processing steps to ensure accurate results.
"""